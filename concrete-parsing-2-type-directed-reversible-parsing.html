<!DOCTYPE html>
<html lang="en">

<head>
  <title>Concrete Parsing 2: Type-directed reversible parsing</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="A simple method to write reversible parsers">
  
  <meta name="author" content="Sofia M.A.">
  
  
  <meta name="keywords" content="syntax">
  

  <meta property="og:site_name" content="Sofia's Blog">
  <meta property="og:title" content="Concrete Parsing 2: Type-directed reversible parsing">
  <meta property="og:url" content="https://sofia-m-a.github.io//concrete-parsing-2-type-directed-reversible-parsing.html">
  <meta property="og:description" content="A simple method to write reversible parsers">
  
  <meta property="og:image" content="https://sofia-m-a.github.io/./images/butterfly.jpg">
  
  
  <meta property="og:type" content="article">
  

  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:site" content="Sofia's Blog">
  <meta property="twitter:title" content="Concrete Parsing 2: Type-directed reversible parsing">
  <meta property="twitter:description" content="A simple method to write reversible parsers">
  
  <meta property="twitter:image" content="https://sofia-m-a.github.io/./images/butterfly.jpg">
  
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="canonical" href="https://sofia-m-a.github.io//concrete-parsing-2-type-directed-reversible-parsing.html">
  <link rel="stylesheet" href="./css/default.css" />
  <link rel="stylesheet" href="./css/code.css" />
</head>

<body>
  <main>
  <article>
    <header>
      <h1>
        <a href="./concrete-parsing-2-type-directed-reversible-parsing.html">Concrete Parsing 2: Type-directed reversible parsing</a>
      </h1>
      <div>
        <small>2022-04-09</small>
        
        <small>(updated: 2022-04-09T08:17:36Z)</small>
        
      </div>
    </header>
    <section>
      <h1 id="reversible-parsing">Reversible parsing</h1>
<p>Following on the previous post, we want to build concrete syntax trees based around a reversible parser-printer pair. Note the printer is not a pretty printer; for that we need an extra formatting step. Here’s one approach I’ve been playing with.</p>
<h2 id="syntax">Syntax</h2>
<p>Here’s the syntax of a small language we will be working with:</p>
<pre><code>program = def*

def = const_def | function_def
const_def = name &#39;:&#39; type &#39;=&#39; expression &#39;;&#39;
function_def = &#39;define&#39; name &#39;(&#39; param_list? &#39;)&#39; statement

name = [a-zA-Z] [a-zA-Z0-9]*

type = &#39;int&#39; | &#39;string&#39; | name | type &#39;[&#39; expression &#39;]&#39;

expression = expression &#39;+&#39; term | expression &#39;-&#39; term | term
term = term &#39;*&#39; factor | term &#39;/&#39; factor | factor
factor = &#39;-&#39; factor | expr2
expr2 = expr2 &#39;[&#39; expression &#39;]&#39; | atom
atom = &#39;(&#39; expression &#39;)&#39; | name | [0-9]+ | &#39;&quot;&#39; escape_or_printable &#39;&quot;&#39;

escape_or_printable = [printable and not \] | &#39;\n&#39; | &#39;\t&#39;

param_list = name &#39;:&#39; type (&#39;,&#39; name &#39;:&#39; type)*
statement
    = &#39;{&#39; statement* &#39;}&#39;
    | &#39;var&#39; name &#39;:&#39; type &#39;=&#39; expression &#39;;&#39;
    | name &#39;=&#39; expression &#39;;&#39;
    | &#39;while&#39; &#39;(&#39; expression &#39;)&#39; statement
    | &#39;if&#39; &#39;(&#39; expression &#39;)&#39; statement (&#39;else&#39; statement)?

comment = &#39;#&#39; [not new-line]* new-line</code></pre>
<h2 id="tokens">Tokens</h2>
<p>First, a boring definition of tokens:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Token</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">TName</span> <span class="dt">Text</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TNumber</span> <span class="dt">IntLiteral</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TString</span> [<span class="dt">StringLiteralChunk</span>]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TUnrecognized</span> <span class="dt">Char</span> <span class="co">-- important for losslessness</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TWhitespace</span> [<span class="dt">Whitespace</span>] <span class="co">-- important for losslessness</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- punctuation</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TColon</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TSemicolon</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TComma</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TEquals</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- brackets</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TLParen</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TRParen</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TLBrace</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TRBrace</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TLBracket</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TRBracket</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- operators</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TPlus</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TMinus</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TAsterisk</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TSlash</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- keywords</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TDefine</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TVar</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TInt</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TString</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TWhile</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TIf</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TElse</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IntLiteral</span> <span class="ot">=</span> <span class="dt">IntLiteral</span> {<span class="ot"> value ::</span> <span class="dt">Natural</span>,<span class="ot"> leadingZeroes ::</span> <span class="dt">Word</span> <span class="co">-- important for losslessness }</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StringLiteralChunk</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">JustChar</span> <span class="dt">Char</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">SlashN</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">SlashT</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Whitespace</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Space</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">NewLine</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Comment</span> <span class="dt">Text</span></span></code></pre></div>
<p>To go along with this, we want <code>tokenize :: String -&gt;  [Token]</code>. Now, here’s how we write our parser:</p>
<h2 id="type-directed-parsing-and-printing">Type-directed Parsing (and Printing)</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">BackToTokens</span> a <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    backToTokens ::</span> a <span class="ot">-&gt;</span> [<span class="dt">Token</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- a parser has access to the remaining tokens, and can fail</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Parser</span> a <span class="ot">=</span> <span class="dt">StateT</span> [<span class="dt">Token</span>] <span class="dt">Maybe</span> a</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Parsable</span> a <span class="kw">where</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    tryParse ::</span> <span class="dt">Parser</span> a</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Program</span> <span class="ot">=</span> <span class="dt">Program</span> [<span class="dt">Def</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">BackToTokens</span>, <span class="dt">Parsable</span>) via (<span class="dt">Many</span> <span class="dt">Def</span>)</span></code></pre></div>
<p>Here, we meet our first type combinator, <code>Many</code>, which we make use of with <code>{-# LANGUAGE DerivingVia #-}</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Many</span> a <span class="ot">=</span> <span class="dt">Many</span> [a]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Many</span> a <span class="ot">=&gt;</span> <span class="dt">BackToTokens</span> (<span class="dt">Many</span> a) <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    backToTokens <span class="ot">=</span> <span class="fu">foldMap</span> backToTokens</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Parsable</span> a <span class="ot">=&gt;</span> <span class="dt">Parsable</span> (<span class="dt">Many</span> a) <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    tryParse <span class="ot">=</span> many tryParse</span></code></pre></div>
<p><code>many</code> comes from <code>Control.Applicative</code>.</p>
<p>Our next type-level parser combinator will be for exactly a particular token. To make this ergonomic, we’ll do some type-level magic with an auxiliary boilerplate class</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- {-# LANGUAGE DataKinds #-}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ToToken</span> (<span class="ot">t ::</span> <span class="dt">Token</span>) <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    toToken ::</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> <span class="dt">Token</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToToken</span> <span class="dt">&#39;TComma</span> <span class="kw">where</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    toToken _ <span class="ot">=</span> <span class="dt">TComma</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- a bunch more boilerplate instances omitted. We won&#39;t need instances for everything, just what we use</span></span></code></pre></div>
<p>Then, we can define the <code>Exactly</code> combinator</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exactly</span> (<span class="ot">t ::</span> <span class="dt">Token</span>) <span class="ot">=</span> <span class="dt">Exactly</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToToken</span> t <span class="ot">=&gt;</span> <span class="dt">BackToTokens</span> (<span class="dt">Exactly</span> t) <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  backToTokens <span class="dt">Exactly</span> <span class="ot">=</span> [toToken (<span class="dt">Proxy</span> <span class="op">@</span>t)]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToToken</span> t <span class="ot">=&gt;</span> <span class="dt">Parsable</span> (<span class="dt">Exactly</span> t) <span class="kw">where</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  tryParse <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>      tokens <span class="ot">&lt;-</span> get</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> tokens <span class="kw">of</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>          (t<span class="op">:</span>ts) <span class="op">|</span> t <span class="op">==</span> toToken (<span class="dt">Proxy</span> <span class="op">@</span>t) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>              put ts</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>              <span class="fu">pure</span> <span class="dt">Exactly</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>          _ <span class="ot">-&gt;</span> empty</span></code></pre></div>
<p>Next up, the ‘Trivial’ combinator</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Trivial</span> a <span class="ot">=</span> <span class="dt">Trivial</span> [<span class="dt">Whitespace</span>] a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BackToTokens</span> a <span class="ot">=&gt;</span> <span class="dt">BackToTokens</span> (<span class="dt">Trivial</span> a) <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">Trivial</span> trivia a) <span class="ot">=</span> <span class="dt">TWhitespace</span> trivia <span class="op">:</span> backToTokens a</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Parsable</span> a <span class="ot">=&gt;</span> <span class="dt">Parsable</span> (<span class="dt">Trivial</span> a) <span class="kw">where</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    tryParse <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        tokens <span class="ot">&lt;-</span> get</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> tokens <span class="kw">of</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">TWhitespace</span> w <span class="op">:</span> rest <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                put rest</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Trivial</span> ws a <span class="ot">&lt;-</span> tryParse</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                <span class="fu">pure</span> (<span class="dt">Trivial</span> (w<span class="op">:</span>ws) a)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span> <span class="dt">Trivial</span> [] <span class="op">&lt;$&gt;</span> tryParse</span></code></pre></div>
<p>Finally, we need a sequential combinator. We’ll call it <code>:~&gt;</code>. We could do</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> (<span class="op">:~&gt;</span>) a b <span class="ot">=</span> (<span class="op">:~&gt;</span>) a b</span></code></pre></div>
<p>but this wouldn’t allow us to gracefully fail when <code>b</code> isn’t present. This is one of the strengths of our concrete syntax approach: returning a representation even when there’s parse errors. So, we go with the following:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> (<span class="op">:~&gt;</span>) a b <span class="ot">=</span> (<span class="op">:~&gt;</span>) a (<span class="dt">Maybe</span> b)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">:~&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">BackToTokens</span> a, <span class="dt">BackToTokens</span> b) <span class="ot">=&gt;</span> <span class="dt">BackToTokens</span> (a <span class="op">:~&gt;</span> b) <span class="kw">where</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  backToTokens (a <span class="op">:~&gt;</span> b) <span class="ot">=</span> backToTokens a <span class="op">&lt;&gt;</span> <span class="fu">maybe</span> [] backToTokens b</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Parsable</span> a, <span class="dt">Parsable</span> b) <span class="ot">=&gt;</span> <span class="dt">Parsable</span> (a <span class="op">:~&gt;</span> b) <span class="kw">where</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  tryParse <span class="ot">=</span> (<span class="op">:~&gt;</span>) <span class="op">&lt;$&gt;</span> tryParse <span class="op">&lt;*&gt;</span> optional tryParse</span></code></pre></div>
<p>Now we’re ready for one of our first complex parsers:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Def</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">ConstDef</span> (<span class="dt">Name</span> <span class="op">:~&gt;</span> <span class="dt">Trivial</span> (<span class="dt">Exactly</span> <span class="dt">&#39;TColon</span>) <span class="op">:~&gt;</span> <span class="dt">Type&#39;</span> <span class="op">:~&gt;</span> <span class="dt">Trivial</span> (<span class="dt">Exactly</span> <span class="dt">&#39;TEquals</span>) <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Trivial</span> (<span class="dt">Exactly</span> <span class="dt">&#39;TSemicolon</span>))</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">FunctionDef</span> (<span class="dt">Trivial</span> (<span class="dt">Exactly</span> <span class="dt">&#39;TDefine</span>) <span class="op">:~&gt;</span> <span class="dt">Name</span> <span class="op">:~&gt;</span> <span class="dt">Trivial</span> (<span class="dt">Exactly</span> <span class="dt">&#39;TLParen</span>) <span class="op">:~&gt;</span> <span class="dt">OptionalParamList</span> <span class="op">:~&gt;</span> <span class="dt">Trivial</span> (<span class="dt">Exactly</span> <span class="dt">&#39;TRParen</span>) <span class="op">:~&gt;</span> <span class="dt">Statement</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BackToTokens</span> <span class="dt">Def</span> <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">ConstDef</span> c) <span class="ot">=</span> backToTokens c</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">FunctionDef</span> f) <span class="ot">=</span> backToTokens f</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Parsable</span> <span class="dt">Def</span> <span class="kw">where</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    tryParse <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        token <span class="ot">&lt;-</span> peek</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> token <span class="kw">of</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="dt">TName</span> _) <span class="ot">-&gt;</span> <span class="dt">ConstDef</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="dt">TDefine</span>) <span class="ot">-&gt;</span> <span class="dt">FunctionDef</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span> empty</span></code></pre></div>
<p>That’s quite a bit. We relied on the existence of one little helper:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">peek ::</span> <span class="dt">Parser</span> (<span class="dt">Maybe</span> <span class="dt">Token</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>peek <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    tokens <span class="ot">&lt;-</span> get</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> dropWhitespace tokens <span class="kw">of</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Nothing</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        t <span class="op">:</span> ts <span class="ot">-&gt;</span> <span class="fu">pure</span> (<span class="dt">Just</span> t)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    dropWhitespace (<span class="dt">TWhitespace</span> _ <span class="op">:</span> ts) <span class="ot">=</span> dropWhitespace ts</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    dropWhitespace ts <span class="ot">=</span> ts</span></code></pre></div>
<p>We may as well introduce the abbreviation</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Only</span> (<span class="ot">t ::</span> <span class="dt">Token</span>) <span class="ot">=</span> <span class="dt">Trivial</span> (<span class="dt">Exactly</span> t)</span></code></pre></div>
<p>too. Now, look at our definition:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Def</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">ConstDef</span> (<span class="dt">Name</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TColon</span> <span class="op">:~&gt;</span> <span class="dt">Type&#39;</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TEquals</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TSemicolon</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">FunctionDef</span> (<span class="dt">Only</span> <span class="dt">&#39;TDefine</span> <span class="op">:~&gt;</span> <span class="dt">Name</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TLParen</span> <span class="op">:~&gt;</span> <span class="dt">OptionalParamList</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TRParen</span> <span class="op">:~&gt;</span> <span class="dt">Statement</span>)</span></code></pre></div>
<p>Writing parsers goes like this:</p>
<ul>
<li>When we have a sequence, join the elements with <code>(:~&gt;)</code> and use the <code>(:~&gt;)</code> instance of <code>BackToTokens</code> and <code>Parsable</code></li>
<li>When we have a choice, peek a token and use that to dispatch to a sequential parser.</li>
</ul>
<p>Let’s write a few more:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">Name</span> [<span class="dt">Whitespace</span>] <span class="dt">Text</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">IntLit</span> <span class="ot">=</span> <span class="dt">IntLit</span> [<span class="dt">WhiteSpace</span>] <span class="dt">IntLiteral</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">StringLit</span> <span class="ot">=</span> <span class="dt">StringLit</span> [<span class="dt">Whitespace</span>] [<span class="dt">StringLiteralChunk</span>]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- instances are just like Trivial and Exactly, above</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Statement</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">SBlock</span> (<span class="dt">Only</span> <span class="dt">&#39;TLBrace</span> <span class="op">:~&gt;</span> <span class="dt">Many</span> <span class="dt">Statement</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">TRBrace</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">SDec</span> (<span class="dt">Only</span> <span class="dt">&#39;TVar</span> <span class="op">:~&gt;</span> <span class="dt">Name</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TColon</span> <span class="op">:~&gt;</span> <span class="dt">Type&#39;</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TEquals</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TSemicolon</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">SAssign</span> (<span class="dt">Name</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TEquals</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TSemicolon</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">SWhile</span> (<span class="dt">Only</span> <span class="dt">&#39;TWhile</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TLParen</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TRParen</span> <span class="op">:~&gt;</span> <span class="dt">Statement</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">SIf</span> (<span class="dt">Only</span> <span class="dt">&#39;TIf</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TLParen</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TRParen</span> <span class="op">:~&gt;</span> <span class="dt">Statement</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TElse</span> <span class="op">:~&gt;</span> <span class="dt">Statement</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BackToTokens</span> <span class="dt">Statement</span> <span class="kw">where</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">SBlock</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">SDec</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">SAssign</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">SWhile</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">SIf</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Parsable</span> <span class="dt">Statement</span> <span class="kw">where</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    tryParse <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        token <span class="ot">&lt;-</span> peek</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> token <span class="kw">of</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> <span class="dt">TLBrace</span> <span class="ot">-&gt;</span> <span class="dt">SBlock</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> <span class="dt">TVar</span> <span class="ot">-&gt;</span> <span class="dt">SDec</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="dt">TName</span> _) <span class="ot">-&gt;</span> <span class="dt">SAssign</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> <span class="dt">TWhile</span> <span class="ot">-&gt;</span> <span class="dt">SWhile</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> <span class="dt">TIf</span> <span class="ot">-&gt;</span> <span class="dt">SIf</span> <span class="op">&lt;$&gt;</span> tryParse</span></code></pre></div>
<p>We can easily transcribe a grammar non-terminal into a Haskell type using these rules. Well, there’s a spanner in the mix: consider left-recursion, like in <code>type</code>. Here’s how we have to handle it:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type&#39;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">TyInt</span> (<span class="dt">Only</span> <span class="dt">&#39;TInt</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TyString</span> (<span class="dt">Only</span> <span class="dt">&#39;TString</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TyName</span> <span class="dt">Name</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TyArray</span> (<span class="dt">Type&#39;</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TLBracket</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TRBracket</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- This is getting very familiar</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BackToTokens</span> <span class="dt">Type&#39;</span> <span class="kw">where</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">TyInt</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">TyString</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">TyName</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    backToTokens (<span class="dt">TyArray</span> x) <span class="ot">=</span> backToTokens x</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Parsable</span> <span class="dt">Type&#39;</span> <span class="kw">where</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    tryParse <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        token <span class="ot">&lt;-</span> peek</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>        base <span class="ot">&lt;-</span> <span class="kw">case</span> token <span class="kw">of</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> <span class="dt">TInt</span> <span class="ot">-&gt;</span> <span class="dt">TyInt</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> <span class="dt">TString</span> <span class="ot">-&gt;</span> <span class="dt">TyString</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="dt">TName</span> _) <span class="ot">-&gt;</span> <span class="dt">TyName</span> <span class="op">&lt;$&gt;</span> tryParse</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span> empty</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>        parseArrayQuals base</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>            parseArrayQuals base <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>                token <span class="ot">&lt;-</span> peek</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> peek <span class="kw">of</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">TLBracket</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>                        inBracket <span class="ot">&lt;-</span> tryParse <span class="op">@</span>(<span class="dt">Only</span> <span class="dt">&#39;TLBracket</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TRBracket</span>)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>                        parseArrayQuals (<span class="dt">TyArray</span> (base <span class="op">:~&gt;</span> <span class="dt">Just</span> inBracket))</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>                    _ <span class="ot">-&gt;</span> <span class="fu">pure</span> base</span></code></pre></div>
<p>We could abstract this into another combinator, but there’s an easier way:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type&#39;</span> <span class="ot">=</span> <span class="dt">Type&#39;</span> <span class="dt">BaseType</span> (<span class="dt">Many</span> (<span class="dt">Only</span> <span class="dt">&#39;TLBracket</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TRBracket</span>))</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BaseType</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">TyInt</span> (<span class="dt">Only</span> <span class="dt">&#39;TInt</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TyString</span> (<span class="dt">Only</span> <span class="dt">&#39;TString</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">TyName</span> <span class="dt">Name</span></span></code></pre></div>
<p>Just use lists!</p>
<p>With this trick in mind, we can fill out the rest of the grammar</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expression</span> <span class="ot">=</span> <span class="dt">Expression</span> <span class="dt">Term</span> [<span class="dt">AddOp</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AddOp</span> <span class="ot">=</span> <span class="dt">Plus</span> (<span class="dt">Only</span> <span class="dt">&#39;TPlus</span> <span class="op">:~&gt;</span> <span class="dt">Term</span>) <span class="op">|</span> <span class="dt">Minus</span> (<span class="dt">Only</span> <span class="dt">&#39;TMinus</span> <span class="op">:~&gt;</span> <span class="dt">Term</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">=</span> <span class="dt">Term</span> <span class="dt">Factor</span> [<span class="dt">MulOp</span>]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MulOp</span> <span class="ot">=</span> <span class="dt">Mul</span> (<span class="dt">Only</span> <span class="dt">&#39;TAsterisk</span> <span class="op">:~&gt;</span> <span class="dt">Factor</span>) <span class="op">|</span> <span class="dt">Div</span> (<span class="dt">Only</span> <span class="dt">&#39;TSlash</span> <span class="op">:~&gt;</span> <span class="dt">Term</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Factor</span> <span class="ot">=</span> <span class="dt">Negate</span> (<span class="dt">Only</span> <span class="dt">&#39;TMinus</span> <span class="op">:~&gt;</span> <span class="dt">Factor</span>) <span class="op">|</span> <span class="dt">FExpr</span> <span class="dt">Expr2</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr2</span> <span class="ot">=</span> <span class="dt">Expr</span> (<span class="dt">Atom</span> <span class="op">:~&gt;</span> <span class="dt">Many</span> (<span class="dt">Only</span> <span class="dt">&#39;TLBracket</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TRBracket</span>)))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Atom</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">AParens</span> (<span class="dt">Only</span> <span class="dt">&#39;TLParen</span> <span class="op">:~&gt;</span> <span class="dt">Expression</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TRParen</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">AName</span> <span class="dt">Name</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">ANumber</span> <span class="dt">IntLit</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">AString</span> [<span class="dt">StringLiteralChunk</span>]</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OptionalParamList</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">NoParams</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">ParamList</span> (<span class="dt">Param</span> <span class="op">:~&gt;</span> <span class="dt">Many</span> (<span class="dt">Only</span> <span class="dt">&#39;TComma</span> <span class="op">:~&gt;</span> <span class="dt">Param</span>))</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Param</span> <span class="ot">=</span> <span class="dt">Param</span> (<span class="dt">Name</span> <span class="op">:~&gt;</span> <span class="dt">Only</span> <span class="dt">&#39;TComma</span> <span class="op">:~&gt;</span> <span class="dt">Type&#39;</span>)</span></code></pre></div>
<h2 id="error-recovery">Error recovery</h2>
<p>Currently, our parsers handle errors of the kind ‘Expected _ here’ just fine, but not ‘Unexpected _ here’. There is a bit of an art as to where to put ‘recovery’ nodes. A first attempt would be:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Def</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">UnexpectedDef</span> <span class="dt">Token</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Statement</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">UnexpectedStatement</span> <span class="dt">Token</span></span></code></pre></div>
<p>The first change is necessary, as all other ‘Unexpected’ tokens will eventually fall to the top-level parser (for <code>Def</code>s) to make sense of. However, allowing unexpected tokens between statements means that we don’t break out of parsing a statement just because of something unexpected, which <em>should</em> make error-recovery better in a lot of cases. Of course, it’s easy to find situations where this doesn’t help; I don’t know of any precise rules for how to make error-tolerant grammars, beyond intuition and testing.</p>
<h2 id="limitations-and-outlook">Limitations and outlook</h2>
<p>The techniques presented here resemble classical LL(1) parsers , with all their limitations. We can add lookahead (imagine a <code>peek2 :: Parser (Maybe Token, Maybe Token)</code>) to emulate LL(k) grammars for higher k, but this still closes off certain classes of grammars to us. However, LL(1) is a good class for parsing most programming-language grammars. It’s similar to the grammar classes that recursive descent parsers and parser combinators (without clever tricks) can handle, and these are popular parsing frameworks</p>
<p>The specifications are somewhat verbose, although they follow straightforwardly from the grammar. Once we have a few type-level ‘parser combinators’ and some term-level parser combinators, the verbosity is similar to classical parser combinator libraries.</p>
<p>It’s possible to combine <code>BackToText</code> and <code>Parsable</code> into one class and try to use one set of combinators for both, but I’m not sure it’s necessarily worth the extra complexity</p>
    </section>
  </article>
</main>

  <script async src="./js/script.js"></script>
</body>

</html>